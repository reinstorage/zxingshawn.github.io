<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="多线程," />










<meta name="description" content="线程和进程 几乎所有的操作系统都支持同时运行多个任务，一个任务通常就是一个程序，每个程序就是一个进程。当一个程序运行时，内部可能包含了多个顺序执行流，每个顺序执行流就是一个线程。">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发多线程知识梳理">
<meta property="og:url" content="https://zxingshawn.github.io/2019/12/26/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/index.html">
<meta property="og:site_name" content="Sean的博客">
<meta property="og:description" content="线程和进程 几乎所有的操作系统都支持同时运行多个任务，一个任务通常就是一个程序，每个程序就是一个进程。当一个程序运行时，内部可能包含了多个顺序执行流，每个顺序执行流就是一个线程。">
<meta property="og:image" content="https://zxingshawn.github.io/2019/12/26/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/xianchengzhuangtai.png">
<meta property="article:published_time" content="2019-12-26T06:24:09.000Z">
<meta property="article:modified_time" content="2019-12-27T02:41:35.857Z">
<meta property="article:author" content="Sean">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zxingshawn.github.io/2019/12/26/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/xianchengzhuangtai.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zxingshawn.github.io/2019/12/26/iOS-多线程知识梳理/"/>





  <title>iOS开发多线程知识梳理 | Sean的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sean的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep positive bro</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxingshawn.github.io/2019/12/26/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sean">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sean的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS开发多线程知识梳理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-26T14:24:09+08:00">
                2019-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><hr>
<p>几乎所有的操作系统都支持同时运行多个任务，一个任务通常就是一个程序，每个程序就是一个进程。当一个程序运行时，内部可能包含了多个顺序执行流，每个顺序执行流就是一个线程。</p>
<a id="more"></a>
<ul>
<li>进程（Process )</li>
</ul>
<p>当一个程序进入内存运行后，即变成一个进程。进程是处于是处于运行过程中的程序，并且具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单位。一般而言，进程有如下特征：</p>
<ol>
<li>独立性：有自己独立的资源，且拥有自己私有的地址空间。在没有经过进程本省的允许下，其他进程是不能直接访问其进程的地址空间的。</li>
<li>动态性：程序只是静态的指令集合，而进程是一个正在系统中活动的指令集合。进程有时间的概念，具有自己的生命周期和各种状态。</li>
<li>并发性：多个进程可以在单个处理器上并发执行，互相不会影响。</li>
</ol>
<ul>
<li>线程（Thread）</li>
</ul>
<p>线程也被称做轻量级进程，线程是进程的执行单元。就像进程在系统中一样，线程在进程中也是独立的，并发的执行流程。一个进程可以拥有多个线程，一个线程必须有一个父进程，但不再拥有系统资源，而是和父进程一起共享父进程的全部资源。多线程由于共享父进程的资源，所以编程更加方便，但是也需要小心线程不会影响到父进程中的其他线程。线程是独立运行的，它并不知道其他线程的存在。线程执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便林另外一个线程可以运行。</p>
<ul>
<li>多线程优点</li>
</ul>
<ol>
<li>进程间不可以共享内存，但线程之间共享内存十分容易。</li>
<li>系统创建进程需要为其重新分配系统资源，但是创建线程代价小得多，因此效率更高</li>
</ol>
<h3 id="为什么要用多线程编程"><a href="#为什么要用多线程编程" class="headerlink" title="为什么要用多线程编程"></a>为什么要用多线程编程</h3><hr>
<p>为了提高资源利用率来提升系统整体效率，实际往往是将耗时操作放在后台执行，避免阻塞主线程，在iOS中UI绘制和用户响应都是主线程。</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><hr>
<p>常用API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;打印当前线程</span><br><span class="line">    NSLog(@&quot;开始：%@   优先级：%d&quot;, [NSThread currentThread], [NSThread currentThread].qualityOfService);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;1.创建NSTread对象，必须调用start方法开始，并且只能传一个参数object</span><br><span class="line">    NSThread *thread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;test&quot;];</span><br><span class="line">    &#x2F;&#x2F;    NSThread *thread &#x3D; [[NSThread alloc] initWithBlock:^&#123;&#125;];</span><br><span class="line">    thread.name &#x3D; @&quot;testThread&quot;;</span><br><span class="line">    thread.qualityOfService &#x3D; NSQualityOfServiceUserInteractive;</span><br><span class="line">    [thread start];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;2.直接创建并启动线程</span><br><span class="line">    &#x2F;&#x2F;    [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;test&quot;];</span><br><span class="line">    &#x2F;&#x2F;    [NSThread detachNewThreadWithBlock:^&#123;&#125;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;3.隐式直接创建</span><br><span class="line">&#x2F;&#x2F;    [NSThread performSelectorInBackground:@selector(run:) withObject:nil];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;    NSLog(@&quot;结束：%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run:(NSObject *)object &#123;</span><br><span class="line">    &#x2F;&#x2F;阻塞休眠</span><br><span class="line">    &#x2F;&#x2F;    [NSThread sleepForTimeInterval:5];</span><br><span class="line">    &#x2F;&#x2F;中止当前线程</span><br><span class="line">    &#x2F;&#x2F;    [NSThread exit];</span><br><span class="line">    NSLog(@&quot;子线程运行：%@ %@  优先级：%d&quot;, [NSThread currentThread], object, [NSThread currentThread].qualityOfService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程的状态</li>
</ul>
<p>线程被启动后，并不是直接进入执行状态，也不是一直处于执行状态，由于线程并发，线程会反复在运行、就绪间切换。创建一个线程后，处于新建状态，系统为其分配内存，初始化成员变量；调用<code>-（void）start；</code>方法后，该线程处于就绪状态，系统为其创建方法调用栈和程序计数器，此时并没有运行，何时运行取决于系统调度。<br><img src="xianchengzhuangtai.png" alt="线程状态"></p>
<ul>
<li>终止子线程</li>
</ul>
<p>每个线程都有一定的优先级，优先级越高获得执行机会越多。目前通过<code>qualityOfService</code>属性来设置，原来的<code>threadPriority</code>由于语义不够清晰，已经被废弃了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSQualityOfServiceUserInteractive：最高优先级，主要用于提供交互UI的操作，比如处理点击事件，绘制图像到屏幕上</span><br><span class="line">NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务</span><br><span class="line">NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级</span><br><span class="line">NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务</span><br><span class="line">NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点</li>
</ul>
<p>使用NSThread进行多线程编程较复杂，需要自己控制多线程的同步、并发，还需要自己控制线程的终止销毁，稍有不留神容易出现错误，对开发者要求较高，一般较少使用。<br><a href=""></a></p>
<h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><hr>
<p>iOS还提供了NSOperation与NSOperationQueue来实现多线程，是基于GCD更高一层的封装，完全面向对象。但是GCD更简单易用、代码可读性也更高。</p>
<p>NSOperationQueue：负责管理系统提交的多个NSOperation，底层维护了一个线程池。不同于GCD中的调度队列FIFO(先进先出)原则。NSOperationQueue对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>
<p>NSOperation： 代表一个多线程任务。</p>
<ul>
<li>为什么要使用NSOperation、NSOPerationQueue？</li>
</ul>
<ol>
<li>可以添加完成的代码块，在操作完成后执行。</li>
<li>添加操作之间的依赖关系，方便的控制执行顺序。</li>
<li>设定操作执行的优先级。</li>
<li>可以很方便的取消一个操作的执行。</li>
<li>使用KVO观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</li>
</ol>
<ul>
<li>常用API</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue;</span><br><span class="line">&#x2F;&#x2F;获取执行当前NSOperation的NSOperationQueue队列</span><br><span class="line">&#x2F;&#x2F;    queue &#x3D; [NSOperationQueue currentQueue];</span><br><span class="line">&#x2F;&#x2F;获取主线程的NSOperationQueue队列</span><br><span class="line">&#x2F;&#x2F;    queue &#x3D; [NSOperationQueue mainQueue];</span><br><span class="line">&#x2F;&#x2F;自定义队列</span><br><span class="line">queue &#x3D; [[NSOperationQueue alloc] init];</span><br><span class="line">&#x2F;&#x2F;队列名</span><br><span class="line">queue.name &#x3D; @&quot;testOperationQueue&quot;;</span><br><span class="line">&#x2F;&#x2F;最大并发操作数（系统有限制，即使设置很大，也会自动调整）</span><br><span class="line">queue.maxConcurrentOperationCount &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;设置优先级</span><br><span class="line">queue.qualityOfService &#x3D; NSQualityOfServiceDefault;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义NSOperation，如果SEL和Block为空，系统不会加入到指定队列</span><br><span class="line">NSInvocationOperation *invocationOperation &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">NSBlockOperation *blockOperation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;blockOperation&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F;添加依赖关系，invocationOperation执行完后才执行blockOperation</span><br><span class="line">[blockOperation addDependency:invocationOperation];</span><br><span class="line">&#x2F;&#x2F;添加到队列中</span><br><span class="line">&#x2F;&#x2F;    [queue addOperation:invocationOperation];</span><br><span class="line">[queue addOperations:@[invocationOperation, blockOperation] waitUntilFinished:NO];</span><br><span class="line">&#x2F;&#x2F;直接添加代码块任务</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印所有的NSOperation</span><br><span class="line">for(int i&#x3D;0; i&lt;queue.operationCount; i++) &#123;</span><br><span class="line">    NSLog(@&quot;队列%@的第%d个NSOperation:%@&quot;, queue.name, i, queue.operations[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;终止所有NSOperation</span><br><span class="line">&#x2F;&#x2F;    [queue cancelAllOperations];</span><br><span class="line">&#x2F;&#x2F;执行完所有NSOperation才能解除阻塞当前线程</span><br><span class="line">&#x2F;&#x2F;    [queue waitUntilAllOperationsAreFinished];</span><br></pre></td></tr></table></figure>

<h3 id="GCD（Grand-Central-Dispatch）"><a href="#GCD（Grand-Central-Dispatch）" class="headerlink" title="GCD（Grand Central Dispatch）"></a>GCD（Grand Central Dispatch）</h3><ul>
<li>基本概念</li>
</ul>
<ol>
<li>队列：队列负责开发者提交的任务，不过不同任务的执行时间不一样，先处理的任务不一定先完成。队列即可是串行的，也可是并行的，队列底层会维持一个线程池来处理任务，串行队列只需要维护一个线程即可，并行队列则需要维护多个线程。</li>
<li>任务：用户提交给队列的工作单元，这些任务将会提交给队列底层维护的线程池。</li>
<li>异步：可以在新的线程中执行任务，但不一定会开辟新的线程。dispatch函数会立即返回，然后Block在后台异步执行。</li>
<li>同步：在当前线程执行任务，不会开辟新的线程。必须等到Block函数执行完毕后，dispatch函数才会返回。</li>
</ol>
<blockquote>
<p>注：队列的串行和并行决定了任务以何种方式执行，执行的异步和同步决定了是否需要开辟新线程处理任务。</p>
</blockquote>
<ul>
<li>特点</li>
</ul>
<ol>
<li>GCD可用于多核的并行运算；</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）；</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）；</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要写任何线程管理代码；</li>
</ol>
<ul>
<li>常用API</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 获取队列 *&#x2F;</span><br><span class="line">&#x2F;&#x2F;获取指定优先级的全局并发队列（flag填0即可，仅预留的参数，使用其他值可能会返回null）</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">&#x2F;&#x2F;创建自定义并行队列</span><br><span class="line">dispatch_queue_t queue1 &#x3D; dispatch_queue_create(&quot;testQueue1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">&#x2F;&#x2F;获取系统主线程关联的串行队列</span><br><span class="line">dispatch_queue_t queue2 &#x3D; dispatch_get_main_queue();</span><br><span class="line">&#x2F;&#x2F;创建自定义串行队列</span><br><span class="line">dispatch_queue_t queue3 &#x3D; dispatch_queue_create(&quot;testQueue3&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">&#x2F;** 提交任务 *&#x2F;</span><br><span class="line">&#x2F;&#x2F;异步提交代码块到并发队列</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;同步提交代码块到自定义并发队列</span><br><span class="line">dispatch_sync(queue1, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;异步提交代码块到串行队列，线程池将在指定时间执行代码块（实际是5秒后加入到队列中，实际并不一定会立马执行，一般精度要求下是没问题的）</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5*NSEC_PER_SEC)), queue2, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;异步提交代码到自定义串行队列，同步函数，无论是在串行还是并行队列中执行，都要执行完才返回，所以要防止线程阻塞和死锁，time表示当前是第几次（如果提交给并发队列，会启动五个线程来执行）</span><br><span class="line">dispatch_apply(5, queue3, ^(size_t time) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实际是个long类型变量，用于判断该代码块是否被执行过</span><br><span class="line">static dispatch_once_t onceToken; </span><br><span class="line">&#x2F;&#x2F;主线程执行一次代码块</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等group执行完后，才能执行下一步</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">&#x2F;** 组（用于需要等待多个任务全部执行完再进行下一步） *&#x2F;</span><br><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;并发执行的代码块1</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;并发执行的代码块2</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等待两个代码块执行完汇总</span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;** 栅栏（用于需要依次执行完多个线程组） *&#x2F;</span><br><span class="line">&#x2F;&#x2F;并发队列异步执行代码块1，2</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    &#x2F;&#x2F;代码块1</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    &#x2F;&#x2F;代码块2</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;1，2执行完后才会执行3，4</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;并发队列异步执行代码块3，4</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    &#x2F;&#x2F;代码块3</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    &#x2F;&#x2F;代码块4</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;** 信号量（用于控制线程的等待和执行） *&#x2F;</span><br><span class="line">&#x2F;&#x2F;创建信号量，value表示初始信号总量，支持多少个操作来执行</span><br><span class="line">dispatch_semaphore_t t &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">&#x2F;&#x2F;发送一个信号，让信号总量+1</span><br><span class="line">dispatch_semaphore_signal(t);</span><br><span class="line">&#x2F;&#x2F;使信号总量-1，如果总量为0，则会一直等待（阻塞所在线程），直到总量大于0则继续执行</span><br><span class="line">dispatch_semaphore_wait(t, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">&#x2F;*1.可以将异步执行变为同步执行，如需要等待下载完后再直接返回数据（我们也可以通过block回调）*&#x2F;</span><br><span class="line">&#x2F;&#x2F;总信号量设置为0</span><br><span class="line">dispatch_semaphore_t t1 &#x3D; dispatch_semaphore_create(0);</span><br><span class="line">&#x2F;&#x2F;执行耗时代码</span><br><span class="line">void (^downloadTask)(void) &#x3D; ^ &#123;</span><br><span class="line">    &#x2F;&#x2F;下载图片</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;完成后发送信号量</span><br><span class="line">    dispatch_semaphore_signal(t1);</span><br><span class="line">&#125;;</span><br><span class="line">downloadTask();</span><br><span class="line">&#x2F;&#x2F;一直等到信号量计数为1才执行下一步，也就是等到图片下载完后</span><br><span class="line">dispatch_semaphore_wait(t1, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">&#x2F;*2.保证线程安全*&#x2F;</span><br><span class="line">&#x2F;&#x2F;设置信号量初始计数为1，保证只能有一个操作能进来</span><br><span class="line">dispatch_semaphore_t t2 &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">&#x2F;&#x2F;相当于加锁，消耗使用计数，如果已经被一个线程使用，后续只能挂起等待信号量回复</span><br><span class="line">dispatch_semaphore_wait(t2, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#x2F;&#x2F;执行业务代码</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;解锁</span><br><span class="line">dispatch_semaphore_signal(t2);</span><br><span class="line"></span><br><span class="line">&#x2F;*3.模拟NSOperationQueue的最大并发操作数*&#x2F;</span><br><span class="line">&#x2F;&#x2F;最大并发操作支持10</span><br><span class="line">dispatch_semaphore_t t3 &#x3D; dispatch_semaphore_create(10);</span><br><span class="line">&#x2F;&#x2F;剩余操作同上，其实就是类似于将NSOperationQueue的maxConcurrentOperationCount设置为10</span><br></pre></td></tr></table></figure>

<ul>
<li>后台运行</li>
</ul>
<p>在App程序进入后台时，我们应该尽量释放内存和保存用户数据或者状态信息。在默认情况下，应该仅在5秒钟处理这些工作，我们可以通过<code>UIApplication</code>的<code>beginBackgroundTaskWithExpirationHandler</code>方法来申请延长处理时间，最多有十分钟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">    &#x2F;&#x2F;声明关闭后台任务代码块</span><br><span class="line">    void (^endBackgroundTask)(UIBackgroundTaskIdentifier backgroudTask) &#x3D; ^(UIBackgroundTaskIdentifier backgroudTask) &#123;</span><br><span class="line">        [[UIApplication sharedApplication] endBackgroundTask:backgroudTask];</span><br><span class="line">        backgroudTask &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;开启后台任务</span><br><span class="line">    __block UIBackgroundTaskIdentifier backgroudTask;</span><br><span class="line">    backgroudTask &#x3D; [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        &#x2F;&#x2F;十分钟内仍然没有完成，系统处理终止句柄</span><br><span class="line">        endBackgroundTask(backgroudTask);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;执行相关代码</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;结束后台任务</span><br><span class="line">    endBackgroundTask(backgroudTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程死锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主队列中增加同步代码块，就会造成死锁，由于同步是需要立即顺序执行的，上述代码中，Block中的方法需要在<code>viewDidLoad</code>结束后才能完成，但是<code>viewDidLoad</code>想要结束又必须先结束Block中的方法，所以相互永久等待，造成了死锁。</p>
<h3 id="GCD会造成循环引用吗？"><a href="#GCD会造成循环引用吗？" class="headerlink" title="GCD会造成循环引用吗？"></a>GCD会造成循环引用吗？</h3><p>直接使用GCD的相关API一般是不会的，block结束后没有循环引用的条件，YYKit的issues下有个有去的讨论：<a href="https://github.com/ibireme/YYKit/issues/41" target="_blank" rel="noopener">dispatch_async的block里面需要_weak self吗？</a></p>
<ul>
<li>注意</li>
</ul>
<ol>
<li>同步执行会在当前线程执行任务，不具有开辟线程的能力或者说没有必要开辟新的线程。并且，同步执行必须等到Block函数执行完毕，dispatch函数才会返回，从而阻塞同一串行队列中外部方法的执行。</li>
<li>异步执行dispatch函数会直接返回，只有异步执行才有开辟新线程的必要，但是异步执行不一定会开辟新线程。</li>
<li>想要开辟新线程必须让任务在异步执行，想要开辟多个线程，只有让任务在并行队列中异步执行才可以。执行方式和队列类型多层组合在一定程度上能够实现对于代码执行顺序的调度。</li>
<li>同步+串行：未开辟新线程，串行执行任务；同步+并行：未开辟新线程，串行执行任务；异步+串行：新开辟一条线程，串行执行任务；异步+并行：开辟多条新线程，并行执行任务；在主线程中同步使用主队列执行任务，会造成死锁。</li>
</ol>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全主要是由于系统的线程调度具有一定的随机性造成的，由于是多并发，多个线程同时对一份数据进行读写，就可能在读取执行一般的时候另外一个线程去写入，导致数据异常。<strong>线程安全即保证线程同步</strong></p>
<ul>
<li>线程安全的类的特征</li>
</ul>
<ol>
<li>该类的对象可以被多个线程安全访问。</li>
<li>每个线程调用对象的任意方法都会得到正确的结果。</li>
<li>每个线程调用对象的任意方法之后，该对象仍保持合理状态。</li>
</ol>
<ul>
<li>@synchronized是对mutex递归锁的封装</li>
</ul>
<p>为了解决这个问题，Objective-C的多线程支持引入同步，使<code>@synchronized</code>修饰代码块，被修饰的代码块可简称为同步代码块，语法格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (obj) &#123;</span><br><span class="line">    &#x2F;&#x2F;同步代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>obj</code>就是同步监视器，当一个线程执行同步前，必须先获得同步监视器的锁定，任何时刻只能有一个线程获得锁定，执行完成后，才会释放，如果此时有新的线程访问，那么新线程会进入休眠状态。通常推荐使用可能被并发访问的共享资源作为同步监视器。</p>
<h3 id="iOS中的锁"><a href="#iOS中的锁" class="headerlink" title="iOS中的锁"></a>iOS中的锁</h3><hr>
<p><strong>1. OSSpinLock(自旋锁)</strong></p>
<ul>
<li>等待锁的线程处于忙等（busy-wait）状态，一直占用着CPU资源；</li>
<li>目前已经不再安全，可能会出现优先级翻转问题；</li>
<li>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁；</li>
<li>需要导入头文件<code>#import &lt;libkern/OSatomic.h&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">OSSpinLock lock &#x3D; OS_SPINLOCK_INIT;</span><br><span class="line">&#x2F;&#x2F;尝试加锁（如果需要等待就不加锁，直接返回false；如果不需要等待加锁，返回true）</span><br><span class="line">bool resule &#x3D; OSSpinLockTry(&amp;lock);</span><br><span class="line">&#x2F;&#x2F;加锁</span><br><span class="line">OSSpinLock(&amp;lock);</span><br><span class="line">&#x2F;&#x2F;解锁</span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p><strong>2. os_unfair_lock</strong></p>
<ul>
<li>用于取代不安全的OSSpinLock，从iOS10开始支持；</li>
<li>从底层调用看，等待os_unfair_locks锁的线程会处于休眠状态，并非忙等；</li>
<li>需要导入头文件<code>#import &lt;os/lock.h&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">os_unfair_lock lock &#x3D; OS_UNFAIR_LOCK_INIT;</span><br><span class="line">&#x2F;&#x2F;尝试加锁</span><br><span class="line">os_unfair_lock_trylock(&amp;lock);</span><br><span class="line">&#x2F;&#x2F;加锁</span><br><span class="line">os_unfair_lock_lock(&amp;lock);</span><br><span class="line">&#x2F;&#x2F;解锁</span><br><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p><strong>3. pthread_mutex</strong></p>
<p><strong>互斥锁</strong></p>
<ul>
<li>mutex叫做“互斥锁”，等待的线程会处于休眠状态</li>
<li>需要导入头文件<code>#import &lt;pthread.h&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化锁的属性</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr,PTHREAD_MUTEX_NORMAL);</span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init (&amp;mutex,&amp;attr);</span><br><span class="line">&#x2F;&#x2F;尝试加锁</span><br><span class="line">pthread_mutex_trylock (&amp;mutex);</span><br><span class="line">&#x2F;&#x2F;加锁</span><br><span class="line">pthread_mutex_lock (&amp;mutex);</span><br><span class="line">&#x2F;&#x2F;解锁</span><br><span class="line">pthread_mutex_unlock (&amp;mutex);</span><br><span class="line">&#x2F;&#x2F;销毁相关资源</span><br><span class="line">pthread_mutexattr_unlock(&amp;attr)；</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p><strong>递归锁</strong></p>
<ul>
<li>递归锁：允许同一个线程对一把锁进行重复加锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化属性</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr,PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">&#x2F;&#x2F; 初始化锁</span><br><span class="line">pthread_mutex_t mutex；</span><br><span class="line">pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line">&#x2F;&#x2F; 销毁属性</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure>

<p><strong>条件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 初始化锁</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">&#x2F;&#x2F;NULL代表使用默认属性</span><br><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">&#x2F;&#x2F; 初始化条件</span><br><span class="line">pthread_cond_t cond;</span><br><span class="line">pthread_cond_init(&amp;cond, NULL);</span><br><span class="line">&#x2F;&#x2F;等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#x2F;&#x2F;激活一个等待条件的线程</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">&#x2F;&#x2F;销毁资源</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br></pre></td></tr></table></figure>

<p><strong>4. NSLock、NSRecursiveLock</strong></p>
<ul>
<li>NSLock是对mutex普通锁的封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSLocking</span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSLock : NSObject &lt;NSLocking&gt;</span><br><span class="line">&#123;</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOl)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化锁</span><br><span class="line">NSLock *lock &#x3D; [[NSLock alloc] init];</span><br></pre></td></tr></table></figure>
<ul>
<li>NSRecursiveLock也是对mutex递归所得封装，API跟NSLock基本一致。</li>
</ul>
<p><strong>5. NSCondition</strong></p>
<ul>
<li>NScondition 是对mutex和cond的封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface NSCondition : NSObject &lt;NSLocking&gt;</span><br><span class="line">- (void)wait;</span><br><span class="line">- (BOOL)waitUntilDate:(NSDate *)limit;</span><br><span class="line">- (void)signal;</span><br><span class="line">- (void)broadcast;</span><br></pre></td></tr></table></figure>

<p><strong>6. NSConditionLock</strong></p>
<ul>
<li>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><strong>7. dispatch_semaphore</strong></p>
<ul>
<li>semaphore叫做信号量；</li>
<li>信号量的初始值，可以用来控制线程并发访问的最大数量；</li>
<li>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;信号量的初始值</span><br><span class="line">int value &#x3D; 1；</span><br><span class="line">&#x2F;&#x2F;初始化信号量</span><br><span class="line">dispatch_semaphore semephore &#x3D; dispatch_semaphore_creat(value);</span><br><span class="line">&#x2F;&#x2F;如果信号量的值&lt;&#x3D;0，当前线程就会进入休眠等待（直到信号量的值&gt;0）</span><br><span class="line">&#x2F;&#x2F;如果信号量的值&gt;0, 就减1，然后往下执行后面的代码</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#x2F;&#x2F;让信号量的值加1</span><br><span class="line">dispatch_semaphore_signal(semaphore)；</span><br></pre></td></tr></table></figure>
<p><strong>8. dispatch_queue</strong></p>
<ul>
<li>直接使用GCD的串行队列，也是可以实现线程同步的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_creat(&quot;lock_queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">&#x2F;&#x2F;任务</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/24/iOS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" rel="next" title="iOS开发基础知识梳理">
                <i class="fa fa-chevron-left"></i> iOS开发基础知识梳理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/27/iOS-%E4%BB%A5View-ViewModel%E5%BD%A2%E5%BC%8F%E6%9E%84%E5%BB%BAUI%E7%BB%84%E4%BB%B6/" rel="prev" title="以View-ViewModel形式构建UI组件">
                以View-ViewModel形式构建UI组件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.JPG"
                alt="Sean" />
            
              <p class="site-author-name" itemprop="name">Sean</p>
              <p class="site-description motion-element" itemprop="description">可以说话的酒馆</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zxingshawn" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhenxing.shang@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/56356fa860b21ee8e71307f7" target="_blank" title="掘金">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>掘金</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/fb22369600b4" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-instagram"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.ithome.com" title="IT之家" target="_blank">IT之家</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://swift.gg" title="swiftGG" target="_blank">swiftGG</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.qtfy7.com" title="且听风吟" target="_blank">且听风吟</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程和进程"><span class="nav-number">1.</span> <span class="nav-text">线程和进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用多线程编程"><span class="nav-number">2.</span> <span class="nav-text">为什么要用多线程编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSThread"><span class="nav-number">3.</span> <span class="nav-text">NSThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSOperation"><span class="nav-number">4.</span> <span class="nav-text">NSOperation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD（Grand-Central-Dispatch）"><span class="nav-number">5.</span> <span class="nav-text">GCD（Grand Central Dispatch）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD会造成循环引用吗？"><span class="nav-number">6.</span> <span class="nav-text">GCD会造成循环引用吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全"><span class="nav-number">7.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS中的锁"><span class="nav-number">8.</span> <span class="nav-text">iOS中的锁</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
