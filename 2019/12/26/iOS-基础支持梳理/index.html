<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS," />










<meta name="description" content="我只是一个搬运工，仅仅为了加深记忆，感谢作者分享，文章大部分来源:进击的蜗牛君  alloc&#x2F;init与new  alloc&#x2F;init  alloc负责为对象的所有成员变量分配内存空间，并且为各个成员变量重置为默认值，如int型为0，BOOL型为NO，指针型变量为nil。仅仅分配空间还不够，还需要init来对对象执行初始化操作，才可以使用它。如果只调用alloc不调用init，也能运行，但可能会">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发基础知识梳理">
<meta property="og:url" content="https://zxingshawn.github.io/2019/12/26/iOS-%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E6%A2%B3%E7%90%86/index.html">
<meta property="og:site_name" content="Sean的博客">
<meta property="og:description" content="我只是一个搬运工，仅仅为了加深记忆，感谢作者分享，文章大部分来源:进击的蜗牛君  alloc&#x2F;init与new  alloc&#x2F;init  alloc负责为对象的所有成员变量分配内存空间，并且为各个成员变量重置为默认值，如int型为0，BOOL型为NO，指针型变量为nil。仅仅分配空间还不够，还需要init来对对象执行初始化操作，才可以使用它。如果只调用alloc不调用init，也能运行，但可能会">
<meta property="article:published_time" content="2019-12-26T05:30:56.000Z">
<meta property="article:modified_time" content="2019-12-26T05:44:59.644Z">
<meta property="article:author" content="Sean">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zxingshawn.github.io/2019/12/26/iOS-基础支持梳理/"/>





  <title>iOS开发基础知识梳理 | Sean的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sean的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep positive bro</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxingshawn.github.io/2019/12/26/iOS-%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sean">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sean的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS开发基础知识梳理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-26T13:30:56+08:00">
                2019-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>我只是一个搬运工，仅仅为了加深记忆，感谢作者分享，文章大部分来源:<a href="https://juejin.im/post/5dafaf36e51d4578176b53bc" target="_blank" rel="noopener">进击的蜗牛君</a></p>
</blockquote>
<h3 id="alloc-init与new"><a href="#alloc-init与new" class="headerlink" title="alloc/init与new"></a>alloc/init与new</h3><hr>
<ul>
<li>alloc/init</li>
</ul>
<p>alloc负责为对象的所有成员变量分配内存空间，并且为各个成员变量重置为默认值，如int型为0，BOOL型为NO，指针型变量为nil。仅仅分配空间还不够，还需要init来对对象执行初始化操作，才可以使用它。如果只调用alloc不调用init，也能运行，但可能会出现未知结果。</p>
<a id="more"></a>
<ul>
<li>new</li>
</ul>
<p>所做的事情和alloc差不多，也是分配内存和初始化。</p>
<ul>
<li>两者区别</li>
</ul>
<p>new只能使用默认的init初始化，而alloc可以使用其他初始化方法，因为显示调用总比隐式调用好，所以往往使用alloc/init来初始化。</p>
<h3 id="“hello”和-NSString-stringWithFormat-”hello”-有何区别？"><a href="#“hello”和-NSString-stringWithFormat-”hello”-有何区别？" class="headerlink" title="@“hello”和[NSString stringWithFormat:@”hello”]有何区别？"></a>@“hello”和[NSString stringWithFormat:@”hello”]有何区别？</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *A &#x3D; @&quot;hello&quot;;</span><br><span class="line">NSString *B &#x3D; @&quot;hello&quot;;</span><br><span class="line">NSString *C &#x3D; [NSString stringWithFormat:@&quot;hello&quot;];</span><br><span class="line">NSString *D &#x3D; [NSString stringWithFormat:@&quot;hello&quot;];</span><br></pre></td></tr></table></figure>
<p><code>@“hello”</code>位于常量池，可重复使用，其中A和B指向的都是同一份内存地址。而<code>[NSString stringWithFormat:@&quot;hello&quot;]</code>是运行时创建出来的，保存在运行时内存（即堆内存），其中C和D指向的内存地址不同，与A、B也不相同。</p>
<h3 id="Propoty修饰符"><a href="#Propoty修饰符" class="headerlink" title="Propoty修饰符"></a>Propoty修饰符</h3><hr>
<p>具体可以分为四类：线程安全、读写权限、内存管理和指定读写方法。</p>
<ul>
<li>线程安全（atomic, nonatomic）</li>
</ul>
<p>如果不写该类修饰符，默认就是atomic。两者的最大区别决定编译器生成的getter/setter方法是否属于原子操作，如果自己写了getter/setter方法，此时用什么都一样。对于atomic来说，getter/setter增加了锁来确保数据操作的完整性，不受其他线程影响。例如线程A的getter方法运行到一半，线程B调用setter方法，name线程A还是能得到一个完整的Value。而对nonatomic来说，多个线程能同时访问操作，就无法保证是否是完成的Value，还会发生脏数据。但是nonatomic更快，开发中往往在可控情况下安全换效率。</p>
<blockquote>
<p>注意：atomic并不能完全保证线程安全，只能保证数据操作的线程安全，例如线程A使用getter方法，同时线程B、C使用setter方法，那最后线程A取到的值有3中可能：原始值、B set的值或C set的值；又例如线程A使用getter方法，线程B同时调用release方法，由于release方法并没有加锁，所有有可能导致cash。</p>
</blockquote>
<ul>
<li>读写权限（readonly, readwrite）</li>
</ul>
<p>readonly只读属性，只会生成getter方法，不会生成setter方法。readwrite读写属性，会生成getter/setter方法，默认是该修饰符。</p>
<ul>
<li>内存管理（strong, weak, assign, copy）</li>
</ul>
<p>strong强引用，适用于对象，引用计数+1, 对象默认是该修饰符。weak弱引用，为这种属性设置新值时，设置方法既不释放旧值，也不保留新值，不会使引用计数加1。当所指对象被销毁时，指针会自动被置为nil，防止野指针。</p>
<p>assgin适用于基础数据类型，如NSIntger,CGFloat,int等，只进行简单赋值，基础数据类型默认是该修饰符。如果用此修饰符修饰对象，对象被销毁时，并不会置空，会造成野指针。copy是为了解决上下文的异常依赖，实际赋值类型不可变对象时，浅拷贝；可变对象时，深拷贝。浅拷贝：指针拷贝。深拷贝：指针与指向内存地址的值拷贝。</p>
<ul>
<li>指定读写方法（setter=, getter=）</li>
</ul>
<p>给getter/setter方法期别名，可以不一致，并且可以与其他属性的getter/setter重名。例如Person类中定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy, setter&#x3D;setNewName:, getter&#x3D;oldName) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *oldName;</span><br></pre></td></tr></table></figure>

<p>那么此时<code>p1.oldName</code>始终是<code>_name</code>的值，而如果声明的顺序交换，此时<code>p1.oldName</code>就是<code>_oldName</code>的值了，如果想得到<code>_name</code>的值，使用<code>p1.name</code>即可，但是此时不能使用<code>-setName:</code>。所以别名都是有意思且不重复的，避免一些想不到问题。</p>
<ul>
<li>strong和copy的区别</li>
</ul>
<p>strong是浅拷贝，仅拷贝指针并增加引用计数；而copy在对于实际赋值对象是可变对象时，是深拷贝。不可变对象使用copy修饰，如NSString，NSArray，NSSet等；可变对象使用strong修饰，如NSMutableString、NSMutableArray，NSMutableSet等，这是为什么呢？由于父类属性可以指向子类对象，试想这样一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface: Person :NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NSMutableString *mutableName &#x3D; [NSMutableString stringWithFormat:@&quot;hello&quot;];</span><br><span class="line">p.name &#x3D; mutableName;</span><br><span class="line">[mutableName appendString:@&quot; world&quot;];</span><br></pre></td></tr></table></figure>

<p>由于<code>Person.name</code>使用的strong修饰，它对于赋值对象进行的浅拷贝，那么<code>Person.name</code>此时实际指向与<code>mutableName</code>指向的同一块内存区，如果<code>mutableName</code>的内容修改，，此时<code>Person.name</code>也会修改，这并不是我们所想要的，所以我们使用copy来修饰，这样即使赋值对象时一个可变对象，也会在setter方法中copy一份不可变对象再赋值。而对于可变对象的属性来说，如果使用copy修饰，从上面可知会得到一个不可变对象再赋值，就会抛出异常，所以我们使用strong。</p>
<ul>
<li>assgin和weak的区别</li>
</ul>
<p>assgin用于基础类型，可以修饰对象，但这个对象再销毁后，这个指针并不会置空，会造成野指针错误。weak用于对象，无法修饰基础类型，并且在对象销毁后，指针会自动置为nil，不会引起野指针崩溃。</p>
<ul>
<li>var、 getter、setter是如何生成并添加到这个类中的？</li>
</ul>
<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”（autosynthesis）。需要强调的是，这个过程由编译时期在编译期执行，所以编译器里看不到这些合成方法(synthesized method)的源代码。除了生成方法代码getter、setter之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。也可以在类的实现代码里通过@synthesize语法来指定实例变量的名字。</p>
<ul>
<li>@protocol和category中如何使用@propety</li>
</ul>
<p>在protocol中使用property只会生成setter和getter方法声明，我们使用属性的目的，是希望遵守协议的对象能实现该属性。category使用@propety也是只会生成setter和getter方法的声明，如果我们真的需要给category增加属性，需要借助于Runtime的关联对象。</p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><hr>
<ul>
<li>深拷贝</li>
</ul>
<p>深拷贝是对内容拷贝，即复制一份原来的内容放在其他内存下，新对象指针指向该内存区域，与原来的对象没有关系。</p>
<ul>
<li>浅拷贝</li>
</ul>
<p>浅拷贝是指对指针的拷贝，即创建一个新指针也指向原对象的内存空间，相当于给原来的对象索引数+1。</p>
<ul>
<li>Copy与MutableCopy</li>
</ul>
<p>对于可变对象来说，Copy与MutableCopy都是深拷贝；对于不可变对象来说，Copy是浅拷贝，MutableCopy是深拷贝：Copy返回的都是不可变对象，MutableCopy返回的都是可变对象。</p>
<ul>
<li>测试案例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr1 &#x3D; @[];</span><br><span class="line">NSArray *arr2 &#x3D; arr1;</span><br><span class="line">NSArray *arr3 &#x3D; [arr1 copy];</span><br><span class="line">NSArray *arr4 &#x3D; [arr1 mutableCopy];</span><br><span class="line"></span><br><span class="line">NSMutableArray *arr5 &#x3D; [NSMutableArray array];</span><br><span class="line">NSMutableArray *arr6 &#x3D; arr5;</span><br><span class="line">NSMutableArray *arr7 &#x3D; [arr5 copy];</span><br><span class="line">NSMutableArray *arr8 &#x3D; [arr5 mutableCopy];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%p %x&quot;, arr1, &amp;arr1);</span><br><span class="line">NSLog(@&quot;%p %x&quot;, arr2, &amp;arr2);</span><br><span class="line">NSLog(@&quot;%p %x&quot;, arr3, &amp;arr3);</span><br><span class="line">NSLog(@&quot;%p %x&quot;, arr4, &amp;arr4);</span><br><span class="line">NSLog(@&quot;%p %x&quot;, arr5, &amp;arr5);</span><br><span class="line">NSLog(@&quot;%p %x&quot;, arr6, &amp;arr6);</span><br><span class="line">NSLog(@&quot;%p %x&quot;, arr7, &amp;arr7);</span><br><span class="line">NSLog(@&quot;%p %x&quot;, arr8, &amp;arr8);</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x604000001970 e7ba22d8</span><br><span class="line">0x604000001970 e7ba22c8</span><br><span class="line">0x604000001970 e7ba22c0</span><br><span class="line">0x604000458360 e7ba22b8</span><br><span class="line">0x6040004581e0 e7ba22b0</span><br><span class="line">0x6040004581e0 e7ba22a8</span><br><span class="line">0x604000001970 e7ba22a0</span><br><span class="line">0x604000458270 e7ba2298</span><br></pre></td></tr></table></figure>

<h3 id="Weak的实现原理"><a href="#Weak的实现原理" class="headerlink" title="Weak的实现原理"></a>Weak的实现原理</h3><hr>
<ul>
<li>前提</li>
</ul>
<p>在Runtime中，为了管理所有对象的引用计数和weak指针，创建了一个全局的SideTables，实际是一个hash表，里面都是SideTable结构体，并且对象的内存地址作为Key，SideTable部分定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    &#x2F;&#x2F;保证原子操作的自旋锁</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    &#x2F;&#x2F;保存引用计数的hash表</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    &#x2F;&#x2F;用于维护weak指针的结构体</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中用于维护weak指针的结构体<code>weak_table_t</code>是一个全局表,其部分定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct weak_table_t &#123;</span><br><span class="line">    &#x2F;&#x2F;保存所有弱引用表的入口，包含所有对象的弱引用表</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    &#x2F;&#x2F;存储空间</span><br><span class="line">    size_t num_entries;</span><br><span class="line">    &#x2F;&#x2F;参与判断引用计数辅助量</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    &#x2F;&#x2F;hash key 最大偏移值</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中所有的weak指针正是在<code>weak_entry_t</code>中，其部分定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    &#x2F;&#x2F;被指对象的地址。前面循环遍历查找的时候就是判断目标地址是否和他相等。</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            &#x2F;&#x2F;可变数组,里面保存着所有指向这个对象的弱引用的地址。当这个对象被释放的时候，referrers里的所有指针都会被设置成nil。</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : 2;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        struct &#123;</span><br><span class="line">            &#x2F;&#x2F; out_of_line_ness field is low bits of inline_referrers[1]</span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>大致流程</li>
</ul>
<p>weak由于不增加引用计数，所以不能在SideTable中与引用计数表放在一起，Runtime单独使用了一个hash表<code>weak_table_t</code>来管理weak，其中底层结构体<code>weak_entry_t</code>以weak指向的对象内存地址为key，value是一个存储该对象所有weak指针的数组。当这个对象dealloc时，查出对应的SideTable，搜索key对应的指针数组，并且遍历数组将所有weak对象置为nil，并清除记录。</p>
<ul>
<li>代码分析（NSObject.mm）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建weak对象</span><br><span class="line">id __weak obj1 &#x3D; obj;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Runtime会调用如下方法初始化</span><br><span class="line">id objc_initWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;如果对象实例为nil，当前weak对象直接置空</span><br><span class="line">    if (!newObj) &#123;</span><br><span class="line">        *location &#x3D; nil;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新指针指向</span><br><span class="line">static id  storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    if (!haveNew) assert(newObj &#x3D;&#x3D; nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass &#x3D; nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;查询当前weak指针原指向的oldSideTable与当前newObj的newSideTable</span><br><span class="line"> retry:</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        oldObj &#x3D; *location;</span><br><span class="line">        oldTable &#x3D; &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable &#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newTable &#x3D; &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable &#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">    &#x2F;&#x2F;解除weak指针在旧对象中注册</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加weak到新对象的注册</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newObj &#x3D; (objc_object *)</span><br><span class="line">            &#x2F;&#x2F;这个地方仍然需要newObj来核对内存地址来找到weak_entry_t，从而删除</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        *location &#x3D; (id)newObj;</span><br><span class="line">    &#125; else &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><hr>
<p>KVC允许以字符串形式简介操作对象的属性，全称为Key Value Coding, 健值编码。</p>
<ul>
<li>底层实现机制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void) setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先查找<code>-set&lt;Key&gt;:</code>代码通过setter方法赋值，如果<code>-set&lt;Key&gt;:</code>没有找到，还会去查找<code>_set&lt;Key&gt;:</code>方法。</li>
<li>否则，检查<code>+(BOOL)accessInstanceVariableDirectly</code>方法，如果你重写了该方法并使其返回NO，则KVC下一步会执行<code>setValue:forUndefineKey:</code>，默认抛出异常。</li>
<li>否则，KVC会依次搜索该类名为<code>_&lt;key&gt;</code> 、 <code>_&lt;isKey&gt;</code> 、 <code>&lt;key&gt;</code> 、<code>&lt;isKey&gt;</code>的成员变量。</li>
<li>如果都没有，则执行<code>setValue:forUnderfinekKey</code>方法，默认抛出异常。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<ol>
<li>首次依次查找<code>-get&lt;key&gt;</code>, <code>-&lt;key&gt;</code>,<code>is&lt;key&gt;</code>代码通过getter方法获取值。</li>
<li>否则，查找<code>countOf&lt;key&gt;</code>，<code>objectIn&lt;Key&gt;AtIndex:</code>和<code>-&lt;key&gt;AtIndexes</code>方法和另外两个中的一个被找到，返回一个响应所有NSArray方法的代理集合，简单来说就是可以当NSArray用。</li>
<li>否则，查找<code>-countOf&lt;key&gt;</code>, <code>-enumeratorOf&lt;key&gt;</code>和<code>-memberOf&lt;key&gt;:</code>方法，如果三个都能找到，返回一个所有NSSet方法的代理集合，简单来说就是可以当NSSet使用。</li>
<li>否则，依次搜索该类中名为<code>_&lt;key&gt;</code>, <code>_&lt;isKey&gt;</code>, <code>&lt;key&gt;</code>, <code>&lt;isKey&gt;</code>的成员变量，返回该成员变量的值。</li>
<li>如果没有，则执行<code>valueForUndefineKey:</code>方法，默认抛出异常。</li>
</ol>
<ul>
<li>Key Path</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
<p>KVC不仅可以操作对象属性，还可以操作对象的”属性链“。如Person中有一个类型为Date的birthday属性，而Date中又有year，month，day等属性，那么Person可以直接通过birthday.year这种 <strong>Key Path</strong>来操作birthday的year属性。</p>
<ul>
<li>如何避免KVC修改readOnly属性？</li>
</ul>
<p>从上述机制可以看出，在没有setter方法时，会检查<code>(BOOL)accessInstanceVariableDirectly</code>来决定是否搜索相似成员变量，因此只需要重写该方法并返回NO即可。</p>
<ul>
<li>如何校验KVC的正确性</li>
</ul>
<p>开发中可能有些需要设定对象属性不可以设定某些值，此时就需要检验Value的可用性，通过如下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br></pre></td></tr></table></figure>

<p>这个方法的默认实现是去探索里面是否有这样的方法<code>-(BOOL)validate&lt;key&gt;:error:</code>,如果有这个方法，就调用这个方法来返回，没有的话就直接返回YES。注意：<em>在KVC设值的时候，并不会主调用该方法去校验，需要开发者手动调用校验，意味着即使实现此方法，也可以赋值成功</em></p>
<ul>
<li>常见的异常情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br></pre></td></tr></table></figure>

<p>没有找到相关的Key，就会抛出<code>NSUndefinedKeyException</code>异常，使用KVC时一般需要重写这两个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>

<p>当给基础类型的对象属性设置为nil时，会抛出<code>NSValidArgumentException</code>异常，一般也需要重写。</p>
<ul>
<li>常见应用场景</li>
</ul>
<ol>
<li>可以灵活的使用字符串动态的取值和设值，但通过KVC操作对象的性能比getter和setter更差。</li>
<li>访问和修改私有属性。</li>
<li>通过<code>-(void)setValuesForKeysWithDictionary:</code>字典转model。</li>
<li>当对容器类使用KVC时，<code>valueForKey：</code>将会被传递给容器中的每一个对象，而不是容器本身进行操作，由此我们可以有效的提取容器中每个对象的指定属性值集合。</li>
<li>使用函数操作容器中的对象，快速对各对象中的基础类型属性做运算，如<code>@avg</code>，<code>@count</code>,<code>@max</code>,<code>@min</code>,<code>@sum</code>。</li>
</ol>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><hr>
<p>KVO提供了一种机制，(基于NSKeyValueObservin协议，所有的Object都是实现了此协议）可以供观察者监听对象属性的变化并接受通知，全称为Key Value Observing，即健值监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用API</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">观察者重写</span><br><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br></pre></td></tr></table></figure>

<ul>
<li>底层实现机制</li>
</ul>
<p>当观察者对对象A注册一个监听时，系统此时会动态创建一个名为NSKVONotifying_A的新类，该类继承自对象A原本的类，并重写被观察者的setter方法，在原方法的调用前后通知观察者值的改变。然后将对象A的isa指针（isa指针告诉Runtime这个对象的类是什么）指向NSKVONotifying_A这个新类，那么对象A就变成了新创建类的实例，不仅如此，Apple还重写了<code>-class</code>方法来隐藏该新类，让人们以为注册前后对象A的类并没有改变，但实际上如果手动新建一个NSKVONotifying_A类，在观察者运行到注册时，便会引起重复类崩溃。</p>
<ul>
<li>注意事项</li>
</ul>
<p>从上述实现原理来看，很明显可以知道，如果没有通过setter赋值，直接赋值该成员变量是不会触发KVO机制的，但是KVC除外，这也侧面证明了KVC和KVO是有内在联系的。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><hr>
<p>分类用于对已有的类添加新方法，并不需要创建新的子类，不需要访问原有类的源代码，可以将类定义模块化地分布到多个分类中。</p>
<ul>
<li>特点</li>
</ul>
<ol>
<li>分类的方法可以与原来类同名，如果在分类中实现了该方法，分类的方法优先级大于原有类方法。（不建议同名，分类的作用是新增方方法，应使用子类重写或者统一加前缀）。</li>
<li>分类只能添加方法，不能添加成员变量。</li>
<li>分类不仅影响原有类，还影响子类。</li>
<li>一个类支持定义多个分类。</li>
<li>如果多个分类中有相同方法，运行时到底调用哪个方法由编译器决定，最后一个参与编译的方法会被调用。</li>
<li>分类是在运行时加载的，不是在编译器。</li>
<li>可以添加属性，但是@propetry不会生成setter和getter方法。也不会生成对应成员变量。（实际没有意义）</li>
</ol>
<ul>
<li>使用场景</li>
</ul>
<ol>
<li>模块化设计：对于一个超大功能类来说，通过分类将其功能拆分，是个十分有效的方式，有利于管理和协同开发。</li>
<li>声明私有方法：我们可以利用分类声明一个私有方法，这样可以外部直接使用该方法，不会报错。</li>
<li>实现非正式协议：由于分类中的方法可以只声明不实现，原来协议中不支持可选方法，就可以通过分类声明可选方法，实现非正式协议。</li>
</ol>
<ul>
<li>为什么不能添加成员变量？</li>
</ul>
<p>分类的实现是基于Runtime动态的将分类中方法添加到类中，Runtime中通过<code>class_addIvar()</code>方法添加成员变量，但苹果对该方法只能在构造一个类的过程中用，不允许对一个已有的类动态的添加成员变量。为什么苹果不允许？这是因为对象在运行期已经给成员变量都分配了内存，如果动态添加属性，不仅需要破坏内部布局，而且已经创建的类的实例也符合当前类的定义，这简直是灾难性的。但是方法保存在类的可变区域中，修改是不会影响类的内存布局的所以没问题。</p>
<ul>
<li>如何添加有效属性？</li>
</ul>
<p>在分类中声明属性可以编译通过，但是使用该属性，会报找不到getter/setter方法，这是由于即使声明属性，也不会生成<code>成员变量</code>，自然也没有必要实现getter/setter方法，那么我们就需要通过Runtime的关联对象来为属性实现getter/setter方法。例如对Person的一个分类增加<code>SPeciaName</code>属性，实现代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person+Test.h&quot;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义关联的key</span><br><span class="line">static const char* specialNameKey &#x3D; &quot;specialName&quot;;</span><br><span class="line"></span><br><span class="line">@implementation Person (Test)</span><br><span class="line"></span><br><span class="line">- (void)setSpecialName:(NSString *)specialName &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一个参数：给哪个对象添加关联</span><br><span class="line">    &#x2F;&#x2F; 第二个参数：关联的key，通过这个key获取</span><br><span class="line">    &#x2F;&#x2F; 第三个参数：关联的value</span><br><span class="line">    &#x2F;&#x2F; 第四个参数:关联的策略</span><br><span class="line">    objc_setAssociatedObject(self, specialNameKey, specialName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)specialName &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据关联的key，获取关联的值。</span><br><span class="line">    return objc_getAssociatedObject(self, specialNameKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>其中关联对象也是存在一个hash表中，通过内次寻址。当对象销毁时，会找到对应存储的关联对象做清理工作。</p>
<p>详见<a href="https://tech.meituan.com/2015/03/03/diveintocategory.html" target="_blank" rel="noopener">《深入理解Objective-C：Category》</a></p>
<h3 id="Extension（扩展）"><a href="#Extension（扩展）" class="headerlink" title="Extension（扩展）"></a>Extension（扩展）</h3><hr>
<p>扩展与分类相似，相当于匿名分类，但分类通常有.h和.m文件，而扩展常用于临时对某个类的接口进行扩展，一般声明私有属性，私有方法，私有成员变量。</p>
<ul>
<li>特点</li>
</ul>
<ol>
<li>可以单独以文件定义，命名方式与分类相同。</li>
<li>通常放在主类的.m中。</li>
<li>扩展是在编译时加载的。</li>
<li>扩展新添加的方法，类一定要实现。</li>
</ol>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><hr>
<p>Block是对C语言的扩展，用来实现匿名函数的特性，Block本质也是OC对象，它内部也有isa指针，是封装了函数调用以及函数调用环境的OC对象。</p>
<ul>
<li>特性</li>
</ul>
<ol>
<li>对于局部变量默认是只对属性。</li>
<li>如果要修改局部变量，声明_block。</li>
<li>block在OC中是对象，持有block的对象可能也被block持有，从而引发循环引用，可以使用weakSelf。</li>
<li>block只是保存了一份代码，只能调用时才会执行。</li>
</ol>
<ul>
<li>底层实现</li>
</ul>
<p>block对应的结构体如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    &#x2F;&#x2F;所有对象都有该指针，用于实现对象相关的功能</span><br><span class="line">    void *isa; </span><br><span class="line">    &#x2F;&#x2F;用于按 bit 位表示一些 block 的附加信息</span><br><span class="line">    int flags;</span><br><span class="line">    &#x2F;&#x2F;保留变量</span><br><span class="line">    int reserved;</span><br><span class="line">    &#x2F;&#x2F;函数指针，指向具体的 block 实现的函数调用地址</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    &#x2F;&#x2F;表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    &#x2F;* Imported variables. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;捕获的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Objective-C语言中，一共有3种类型的block：<code>_NSConcreteGlobalBlock</code>全局的静态block，不会访问任何外部变量。<code>_NSConcreteStackBlock</code>保存在栈中的block，当函数返回时会被销毁。<code>_NSConcreteMallocBlock</code>保存在堆中的block，当引用计数为0时会被销毁。</p>
<ul>
<li>适用场景</li>
</ul>
<p>事件响应，数据传递，链式语法。</p>
<ul>
<li>答疑</li>
</ul>
<p><strong>1. 为什么不能直接修改局部变量？</strong></p>
<p>这是因为block会重新生成一份变量，所以局部变量修改不会影响block的变量，而且编译器加了限制，block中的变量也不允许修改。</p>
<p><strong>2. 为什么能修改全局变量和静态变量</strong></p>
<p>全局变量所占用的内存只有一份，供所有函数共同调用，block可以直接使用，而不需要深拷贝或者使用变量指针。静态变量实际与_block修饰类似，block是直接使用的指向静态变量的指针，并未重新深考贝。</p>
<p><strong>3. 如何修改局部变量</strong></p>
<p>将局部变量使用_block修饰，告诉编译器这个局部变量是可以修改的，那么block不会再生成一份，而是复制使用该局部变量的指针。</p>
<p><strong>4. 为什么要在block中使用strongWeak</strong></p>
<p>我们为了防止循环引用使用了<code>weakSelf</code>, 但是某些情况在block执行过程中，会出现self突然释放的情况，导致运行不正确，所以我们使用<code>strongSelf</code>来增加强引用，保证后续代码可以正常运行。那么岂不是会导致循环引用? 确实会，但是只是在block代码块的作用域里，一旦执行结束，strongSelf就会释放，这个临时的循环引用就会自动打破。</p>
<p><strong>5. block用copy还是strong修饰</strong></p>
<p>MRC下使用copy，ARC下都可以。MRC下block创建时，如果block中使用了成员变量，齐类型是<code>_NSConcreteStackBlock</code>,它的内存是放在栈区，作用域仅仅是在初始化的区域内，一旦外部使用，就可能造成崩溃，所以一般使用<code>copy</code>来将blcok拷贝到堆内存，此时类型为<code>_NSConcreteMallocBlock</code>,使得block可以在声明域外使用。ARC下只有<code>_NSConcreteGlobleBlock</code>和<code>_NSConcreteMallocBlock</code>类型，如果block中使用了成员变量，其类型是<code>_NSConcreteMallocBlock</code>，所以无论是<code>strong</code>还是<code>copy</code>都可以。</p>
<p><strong>6. 如何不使用_block修改局部变量？</strong></p>
<p>虽然编译器做了限制，但是我们仍然可以在block中通过指针修改，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">void (^test)() &#x3D; ^ &#123;</span><br><span class="line">    &#x2F;&#x2F;通过使用指针绕过了编译器限制，但是由于block中是外面局部变量的拷贝，所以即使修改了，外面局部变量也不会变，实际作用不大。</span><br><span class="line">    int *p &#x3D; &amp;a;</span><br><span class="line">    *p &#x3D; 2;</span><br><span class="line">    NSLog(@&quot;%d&quot;, a);</span><br><span class="line">&#125;;</span><br><span class="line">test();</span><br><span class="line">NSLog(@&quot;%d&quot;, a);</span><br></pre></td></tr></table></figure>

<p>详见<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">《谈Objective-C block实现》</a></p>
<h3 id="Objective-C对象模型"><a href="#Objective-C对象模型" class="headerlink" title="Objective-C对象模型"></a>Objective-C对象模型</h3><hr>
<p>所有对象在runtime层都是以struct展示的，NSObject就是一个包含了isa指针的结构体，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而Class也是个包含了isa的结构体，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p><code>objc_object</code>中的isa指针告诉了runtime自己指向了什么类，<code>objc_class</code>中的isa指向父类，最终根元类的isa会指向自己，形成闭环。Objective-C 2.0中并未具体暴露实现，但我们可以看到Objective—C 2.0中的大概实现，包含了父类，成员变量，方法表等。</p>
<ul>
<li>常见使用</li>
</ul>
<ol>
<li>动态的修改isa的值，即isa swizzling,例如KVO。</li>
<li>动态的修改methodLists，即Method Swizzling，例如Category。</li>
</ol>
<h3 id="ARC与GC"><a href="#ARC与GC" class="headerlink" title="ARC与GC"></a>ARC与GC</h3><hr>
<p>ARC（Automatic Reference Counting）自动引用计数，是苹果在WWDC 2011大会上提出的内存管理计数，常应用于iOS和MacOS。GC（Garbage Collection）垃圾回收机制，由于Java的流行而广为人知，简单说就是系统定期查找不用的对象，并释放器内存。</p>
<ul>
<li>ARC一定不会内存泄漏吗？</li>
</ul>
<p>不是的，虽然大部分使用ARC的内存管理都做的很好，但是如果使用不当，仍然会造成内存泄漏，例如循环引用：OC与Core Foundation类进行桥接的时候，管理不当也会内存泄漏：指针未清空，造成野指针等。</p>
<ul>
<li>两者的区别</li>
</ul>
<ol>
<li>在性能上，GC需要一套额外的系统来跟踪处理内存，分析那些内存是需要释放的，相对来说就需要更多的计算；ARC是开发者自己来管理资源的释放，不需要额外系统，性能比GC高。</li>
<li>GC回收内存时，由于定时跟踪回收，无用内存无法及时释放，并且需要暂停当前程序，如果资源很多，这个延迟就会很大；ARC只需要引用计数为0便立即释放，没有延迟。</li>
</ol>
<h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><hr>
<p>分为五个区：栈区，堆区，全局区，常量区，代码区。程序启动后，全局区，常量区和代码区是已经固定的，不会改变。</p>
<ul>
<li>栈区（stack）</li>
</ul>
<p>存一些局部变量，函数跳转地址，现场保护等，该区由系统处理，无需我们干预。大量的局部变量深递归，函数循环都可能耗尽栈内存而造成程序崩溃。</p>
<ul>
<li>堆区（heap）</li>
</ul>
<p>即运行时内存，我们创建对象就是在这里，需要开发者来管理。</p>
<ul>
<li>全局区/静态区</li>
</ul>
<p>用于存放全局变量和静态变量，初始化的放在一块区域，未初始化的放在相邻的一块区域。</p>
<ul>
<li>常量区</li>
</ul>
<p>存放常量，如字符串常量，const常量。</p>
<ul>
<li>代码区</li>
</ul>
<p>存放代码。</p>
<h3 id="static，const与extern"><a href="#static，const与extern" class="headerlink" title="static，const与extern"></a>static，const与extern</h3><hr>
<p>static修饰的变量存储在静态区，在编译时就分配好了内存，会一直存在app内存中直到停止运行。该静态区只会初始化一次，在内存中只有一份，并且限制了它只能在声明的作用域中使用，例如单利。<em>注：static也可以在.h文件中声明，但是由于头文件可以被其他文件任意引用使用，此时限制作用域没有任何意义，违背了它的初衷，而且重复声明也会报错。</em></p>
<p><strong>const</strong>常用于声明常量，只读不可写，该常量存储在常量区，编译时就分配了相关内存，也会一直存在app内存直到停止运行，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int const *p   &#x2F;&#x2F;  *p只读 ;p变量</span><br><span class="line">int * const p  &#x2F;&#x2F; *p变量 ; p只读</span><br><span class="line">const int * const p &#x2F;&#x2F;p和*p都只读</span><br><span class="line">int const * const p   &#x2F;&#x2F;p和*p都只读</span><br></pre></td></tr></table></figure>

<p><strong>extern</strong>用于声明外部全局变量/常量，告诉编译器需要找对应的全局变量，需要在.m中实现，如下写法是错误的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Person.h</span><br><span class="line">extern NSString *const Test &#x3D; @&quot;test&quot;;</span><br></pre></td></tr></table></figure>

<p>正确的使用方法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Person.h</span><br><span class="line">extern NSString *const Test;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Person.m</span><br><span class="line">NSString *const Test &#x3D; @&quot;test&quot;;</span><br></pre></td></tr></table></figure>

<p>它常用于让当前类可以使用其他类的全局变量/常量，也经常用于统一管理全局变量/常量，更规范整洁，并且在打包时配合const使用，可以避免其他人修改。extern可以在多处声明，但是实现只能是一份，否则会报重复定义。</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><hr>
<p>预处理是C语言的一部分，在编译之前，编译器会对这些预处理进行处理，这些预处理的结果与源程序一起编译，</p>
<ul>
<li>特征</li>
</ul>
<ol>
<li>预处理命令都必须以#开头。</li>
<li>通常位于程序开头部分。</li>
</ol>
<ul>
<li>常用预处理命令</li>
</ul>
<ol>
<li>宏定义： #define，#undef。</li>
<li>条件编译： #ifdef，#ifndef，#else，#endif。</li>
<li>其他 #include（C），#import(Objective-C)。</li>
</ol>
<ul>
<li>宏</li>
</ul>
<ol>
<li>宏并不是C语句，既不是变量也不是常量，所以无需使用=号赋值，也无需用；结束。</li>
<li>编译器对宏只进行查找和替换，将所有出现宏的地方换成该宏的字符串，因此需要开发者自己保证宏定义是正确的。</li>
<li>宏可以带参数，最好是将参数用（）包住，否则如果参数是个算术式，直接替换会导致错误，</li>
<li>占用代码段，大量使用会导致二进制文件增大。</li>
</ol>
<h3 id="class与-import"><a href="#class与-import" class="headerlink" title="@class与#import"></a>@class与#import</h3><hr>
<p><code>@class</code>仅仅是告诉编译器有这个类，至于类里有什么信息，这里是不需要知道的，无法使用该类的实例变量，属性和方法，其编译效率较<code>#import</code>更高,因为<code>#import</code>需要把引用类的所有文件都走一遍，而<code>@class</code>不用。<code>#import</code>还会造成递归引用，如果A、B两类只相互引用，不会报错，但是如果任意一方声明了对方的实例，就会报错。</p>
<h3 id="如何禁止调用已有方法"><a href="#如何禁止调用已有方法" class="headerlink" title="如何禁止调用已有方法"></a>如何禁止调用已有方法</h3><hr>
<p>由于OC中并不能隐藏系统方法，例如我们在实现单例时，未来避免其他人对单例类new、allco、copy、以及mutableCopy，保证整个系统中只有一个单例实例，我们可以在头文件中声明不可用的方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;更简洁</span><br><span class="line">+(instancetype) alloc NS_UNAVAILABLE;</span><br><span class="line">+(instancetype) new NS_UNAVAILABLE;</span><br><span class="line">-(instancetype) copy NS_UNAVAILABLE;</span><br><span class="line">-(instancetype) mutableCopy NS_UNAVAILABLE;</span><br><span class="line">&#x2F;&#x2F;能自定义提示语</span><br><span class="line">+(instancetype) alloc __attribute__((unavailable(&quot;alloc not available, call sharedInstance instead&quot;)));</span><br><span class="line">+(instancetype) new __attribute__((unavailable(&quot;call sharedInstance instead&quot;)));</span><br><span class="line">-(instancetype) copy __attribute__((unavailable(&quot;call sharedInstance instead&quot;)));</span><br><span class="line">-(instancetype) mutableCopy __attribute__((unavailable(&quot;call sharedInstance instead&quot;)));</span><br></pre></td></tr></table></figure>

<h3 id="nil-Nil-NULL及NSNull之间的区别"><a href="#nil-Nil-NULL及NSNull之间的区别" class="headerlink" title="nil Nil NULL及NSNull之间的区别"></a>nil Nil NULL及NSNull之间的区别</h3><hr>
<p>NULL是C语言的用法，此时调用函数或者访问成员变量，会报错。可以用来赋值基本数据类型来表示空。nil和Nil是OC语法，调用函数或者访问成员变量不会报错，nil是对object对象置为空，Nil是对Class类型的指针置空。NSNull是一个类，由于nil比较特殊，在Array和Dictionary中被用于标记结束，所以不能存放nil，我们可以通过NSNull来表示数据为空。但是向NSNull发送消息会报错。</p>
<h3 id="NSDictionary实现原理"><a href="#NSDictionary实现原理" class="headerlink" title="NSDictionary实现原理"></a>NSDictionary实现原理</h3><hr>
<p>NSDictionary（字典）是使用哈希表Hash table（也叫散列表）来实现的。哈希表是根据（key）而直接访问在内存存储位置的数据结构，也就是说，它通过计算一个关于键（key）值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做哈希表。也就是说哈希表的本质是一个数组，数组中每一个元素其实是一个NSDictionary键值对。</p>
<h3 id="a与-framework"><a href="#a与-framework" class="headerlink" title=".a与.framework"></a>.a与.framework</h3><hr>
<ul>
<li>什么是库？</li>
</ul>
<p>库是共享程序代码的方式，一般分为静态库和动态库。</p>
<ul>
<li>静态库与动态库的区别？</li>
</ul>
<p>静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。文件后缀一般为.a, 开发者自己建立的.framework可以直接使用。详见<a href="http://www.cocoachina.com/articles/17730" target="_blank" rel="noopener">《iOS中.a与.framework库的区别》</a></p>
<h3 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h3><hr>
<p>详见<a href="http://www.cocoachina.com/articles/20022" target="_blank" rel="noopener">《iOS响应链（Responder Chain）》</a></p>
<h3 id="main-函数之前发生了什么？"><a href="#main-函数之前发生了什么？" class="headerlink" title="main()函数之前发生了什么？"></a>main()函数之前发生了什么？</h3><hr>
<p>详见<a href="https://www.jianshu.com/p/5efe327ac7ea" target="_blank" rel="noopener">《iOS程序main函数之前发生什么》</a></p>
<h3 id="synthesize和-dynamic？"><a href="#synthesize和-dynamic？" class="headerlink" title="@synthesize和@dynamic？"></a>@synthesize和@dynamic？</h3><hr>
<p>@synthesize语义是如果你没有手动是实现setter/getter方法，那么编译器会自动加上这个两个方法。可以用来改变实例变量的名称，如<code>@synthesize firstName = _myFirstName</code>。</p>
<p>@dynamic是告诉编译器不需要它自动生成，有用户自己生成（当然对于readonly的属性只提供getter即可）。假如一个属性被声明为@dynamic var ，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到instance.var = someVar, 由于缺setter方法会导致程序崩溃；或者当运行到sameVar = var时，由于缺少getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</p>
<ul>
<li>有了自动合成属性实例变量之后，@synthesize还有哪些使用场景</li>
</ul>
<p>我们要搞清楚一个问题，什么情况下不会autosynthesis（自行合成）？</p>
<ol>
<li>同时重写了setter和getter时；</li>
<li>重写了只读属性的getter时；</li>
<li>使用了@dynamic时；</li>
<li>在@protocol中定义的所有属性；</li>
<li>在category中定义的所有属性；</li>
<li>重载的属性，当你在子类中重载父类中的属性，你必须使用@synthesize来手动合成ivar。除了后三条，对其他几个我们可以总结出一个规律；当你想手动管理@property的所有内容时，你就会尝试通过实现@property的所有“存取方法”（the accessor methods）或者使用@dynamic来达到这个目的，这是编译器就会认为你打算手动管理@propetry，于是编译器就禁用了autosynthesis（自动合成）。因为有了autosynthesis（自动合成），大部分开发者已经不习惯手动定义ivar，而是依赖于autosynthesis（自动合成），但是一旦你需要使用ivar，而autosynthesis（自动合成）友失效了，如果不去手动定义ivar，那么你就是借助@synthesize来手动合成ovar。</li>
</ol>
<h3 id="BAD-ACCESS"><a href="#BAD-ACCESS" class="headerlink" title="BAD_ACCESS"></a>BAD_ACCESS</h3><hr>
<p>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。</p>
<ul>
<li>如何调试？</li>
</ul>
<ol>
<li>重写object的respondsToSelector，显示出现EXEC_BAD_ACCES前访问的最后一个object。</li>
<li>通过Edit Scheme-Diagnostics-Zombie Objects。</li>
<li>通过全局断点。</li>
<li>通过Edit Scheme-Diagnostics-Address Sanitizer。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/25/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.JPG"
                alt="Sean" />
            
              <p class="site-author-name" itemprop="name">Sean</p>
              <p class="site-description motion-element" itemprop="description">可以说话的酒馆</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zxingshawn" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhenxing.shang@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/56356fa860b21ee8e71307f7" target="_blank" title="掘金">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>掘金</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/fb22369600b4" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-instagram"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.ithome.com" title="IT之家" target="_blank">IT之家</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://swift.gg" title="swiftGG" target="_blank">swiftGG</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.qtfy7.com" title="且听风吟" target="_blank">且听风吟</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc-init与new"><span class="nav-number">1.</span> <span class="nav-text">alloc&#x2F;init与new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“hello”和-NSString-stringWithFormat-”hello”-有何区别？"><span class="nav-number">2.</span> <span class="nav-text">@“hello”和[NSString stringWithFormat:@”hello”]有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Propoty修饰符"><span class="nav-number">3.</span> <span class="nav-text">Propoty修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝与浅拷贝"><span class="nav-number">4.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Weak的实现原理"><span class="nav-number">5.</span> <span class="nav-text">Weak的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVC"><span class="nav-number">6.</span> <span class="nav-text">KVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVO"><span class="nav-number">7.</span> <span class="nav-text">KVO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">8.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extension（扩展）"><span class="nav-number">9.</span> <span class="nav-text">Extension（扩展）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block"><span class="nav-number">10.</span> <span class="nav-text">Block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Objective-C对象模型"><span class="nav-number">11.</span> <span class="nav-text">Objective-C对象模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC与GC"><span class="nav-number">12.</span> <span class="nav-text">ARC与GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分区"><span class="nav-number">13.</span> <span class="nav-text">内存分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static，const与extern"><span class="nav-number">14.</span> <span class="nav-text">static，const与extern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预处理"><span class="nav-number">15.</span> <span class="nav-text">预处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class与-import"><span class="nav-number">16.</span> <span class="nav-text">@class与#import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何禁止调用已有方法"><span class="nav-number">17.</span> <span class="nav-text">如何禁止调用已有方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil-Nil-NULL及NSNull之间的区别"><span class="nav-number">18.</span> <span class="nav-text">nil Nil NULL及NSNull之间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSDictionary实现原理"><span class="nav-number">19.</span> <span class="nav-text">NSDictionary实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a与-framework"><span class="nav-number">20.</span> <span class="nav-text">.a与.framework</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应链"><span class="nav-number">21.</span> <span class="nav-text">响应链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-函数之前发生了什么？"><span class="nav-number">22.</span> <span class="nav-text">main()函数之前发生了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synthesize和-dynamic？"><span class="nav-number">23.</span> <span class="nav-text">@synthesize和@dynamic？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BAD-ACCESS"><span class="nav-number">24.</span> <span class="nav-text">BAD_ACCESS</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
